<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Dungeon Crawler</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: #0d0d0d;
      color: #e0e0e0;
      font-family: "SF Mono", "Consolas", "Monaco", monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }
    h1 {
      font-size: 1.5rem;
      margin: 0 0 0.5rem;
      letter-spacing: 0.1em;
      color: #7ee8fa;
    }
    .sub {
      font-size: 0.75rem; color: #888; margin-bottom: 1rem;
    }
    #game-wrap {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 0.5rem;
    }
    #grid {
      display: inline-grid;
      gap: 0;
      font-size: 18px;
      line-height: 1.1;
      letter-spacing: 0.05em;
    }
    #grid .cell {
      width: 1.1em;
      height: 1.1em;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #grid .cell.player { color: #7ee8fa; }
    #grid .cell.enemy { color: #f87171; }
    #grid .cell.goal { color: #86efac; }
    #grid .cell.health { color: #86efac; }
    #grid .cell.gold { color: #fde047; }
    #grid .cell.wall { color: #404040; }
    #grid .cell.trail { color: #525252; }
    #grid .cell.floor { color: #262626; }
    #stats {
      margin-top: 0.75rem;
      font-size: 0.9rem;
      color: #a3a3a3;
    }
    #msg {
      min-height: 1.5em;
      margin-top: 0.25rem;
      color: #fde047;
      font-size: 0.85rem;
    }
    #controls {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.5rem;
    }
    .screen {
      text-align: center;
      max-width: 420px;
    }
    .screen h2 { font-size: 1.1rem; margin-bottom: 1rem; color: #86efac; }
    .screen p { margin: 0.5rem 0; line-height: 1.5; }
    .btn {
      display: inline-block;
      margin: 0.5rem;
      padding: 0.6rem 1.2rem;
      background: #262626;
      color: #7ee8fa;
      border: 1px solid #404040;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.95rem;
    }
    .btn:hover { background: #333; border-color: #7ee8fa; }
    .hidden { display: none !important; }
    #best { color: #86efac; font-size: 0.85rem; margin-top: 0.5rem; }
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
(function() {
  const LEVEL_1 = [
    "###############",
    "#...........#.#",
    "#.+.........#.#",
    "#..#######.....#",
    "#..#.....#.....#",
    "#..#.@...#.....#",
    "#..#.....#.....#",
    "#..#####.#####.#",
    "#..............#",
    "#......E....$..#",
    "#....#####.....#",
    "#....#...#.....#",
    "#....#.E.#.....#",
    "#....#...+..G..#",
    "###############"
  ];
  const LEVEL_2 = [
    "###################",
    "#.+.......$.......#",
    "#........E........#",
    "#.#####.#####.#####",
    "#.#...........#..#",
    "#.#..@.........#.#",
    "#.#.............+#",
    "#.#...E..........#",
    "#.#####.#####....#",
    "#...........#....#",
    "#.....E......#....#",
    "#....#####...#....#",
    "#....#...+.#.#....#",
    "#....#.....#.#.$..#",
    "#####.......###G###",
    "###################"
  ];
  const LEVEL_3 = [
    "#####################",
    "#.+.$.......$.......+#",
    "#.....E...E...E......#",
    "#####.#####.#####.#####",
    "#.#...........#.....#",
    "#.#...........#.....#",
    "#.#....@......#.....#",
    "#.#...........#.....#",
    "#.#...E...E....#.....#",
    "#.#####.#####.#.....#",
    "#..............$....#",
    "#......E............#",
    "#.....#####.........#",
    "#.....#...+.#.......#",
    "#.....#.....#...E...#",
    "#####.#####.#####.#####",
    "#.$.................G#",
    "#####################"
  ];
  const LEVELS = [LEVEL_1, LEVEL_2, LEVEL_3];
  const G = "G", E = "E", H = "+", $ = "$", F = ".", W = "#", P = "@", T = "=";
  const MAX_HP = 5;

  function copyGrid(level) {
    return level.map(row => row.split(""));
  }
  function findCells(grid, ch) {
    const out = [];
    grid.forEach((row, r) => row.forEach((cell, c) => { if (cell === ch) out.push([r, c]); }));
    return out;
  }
  function getCell(grid, r, c) {
    if (r >= 0 && r < grid.length && c >= 0 && c < grid[0].length) return grid[r][c];
    return W;
  }
  function setCell(grid, r, c, ch) {
    if (r >= 0 && r < grid.length && c >= 0 && c < grid[0].length) grid[r][c] = ch;
  }
  function moveEnemies(grid, enemies, pr, pc, tron) {
    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
    const valid = [G, H, $, F];
    let damage = 0;
    const toRemove = [];
    enemies.forEach((pos, i) => {
      let [er, ec] = pos;
      const shuffled = [...dirs].sort(() => Math.random() - 0.5);
      if (tron) {
        for (const [dr, dc] of shuffled) {
          const nr = er + dr, nc = ec + dc;
          const cell = getCell(grid, nr, nc);
          if (cell === P) { damage++; return; }
          if (valid.includes(cell)) {
            setCell(grid, er, ec, T);
            setCell(grid, nr, nc, E);
            enemies[i] = [nr, nc];
            return;
          }
          if (cell === W || cell === T) {
            toRemove.push(i);
            setCell(grid, er, ec, T);
            return;
          }
        }
        return;
      }
      if (Math.random() < 0.5) {
        const toward = [];
        if (pr !== er) toward.push([pr > er ? 1 : -1, 0]);
        if (pc !== ec) toward.push([0, pc > ec ? 1 : -1]);
        toward.sort(() => Math.random() - 0.5);
        for (const [dr, dc] of toward) {
          const nr = er + dr, nc = ec + dc;
          const cell = getCell(grid, nr, nc);
          if (cell === P) { damage++; return; }
          if (valid.includes(cell)) {
            setCell(grid, er, ec, F);
            setCell(grid, nr, nc, E);
            enemies[i] = [nr, nc];
            return;
          }
        }
        return;
      }
      for (const [dr, dc] of shuffled) {
        const nr = er + dr, nc = ec + dc;
        const cell = getCell(grid, nr, nc);
        if (cell === P) { damage++; return; }
        if (valid.includes(cell)) {
          setCell(grid, er, ec, F);
          setCell(grid, nr, nc, E);
          enemies[i] = [nr, nc];
          return;
        }
      }
    });
    toRemove.sort((a,b)=>b-a).forEach(i => enemies.splice(i, 1));
    return damage;
  }

  function loadBest() {
    try {
      const s = localStorage.getItem("dungeon_best");
      if (s) { const [g, t] = s.split(",").map(Number); return { gold: g, turns: t }; }
    } catch (_) {}
    return null;
  }
  function saveBest(gold, turns) {
    try { localStorage.setItem("dungeon_best", gold + "," + turns); } catch (_) {}
  }
  function isBetter(gold, turns, best) {
    if (!best) return true;
    if (gold > best.gold) return true;
    if (gold === best.gold && turns < best.turns) return true;
    return false;
  }

  let state = null;
  let mode = "classic";

  function renderGrid(grid) {
    const wrap = document.getElementById("grid-wrap");
    const gridEl = document.getElementById("grid");
    gridEl.innerHTML = "";
    gridEl.style.gridTemplateColumns = `repeat(${grid[0].length}, 1.1em)`;
    grid.forEach(row => {
      row.forEach(cell => {
        const span = document.createElement("span");
        span.className = "cell " + (
          cell === P ? "player" : cell === E ? "enemy" : cell === G ? "goal" :
          cell === H ? "health" : cell === $ ? "gold" : cell === W ? "wall" :
          cell === T ? "trail" : "floor"
        );
        span.textContent = cell;
        gridEl.appendChild(span);
      });
    });
  }

  function runLevel(levelNum) {
    const grid = copyGrid(LEVELS[levelNum]);
    const start = findCells(grid, P);
    const goal = findCells(grid, G)[0];
    const enemies = findCells(grid, E).map(([r, c]) => [r, c]);
    state.grid = grid;
    state.pr = start[0][0];
    state.pc = start[0][1];
    state.goal = goal;
    state.enemies = enemies;
    state.levelNum = levelNum;
    state.levelTurns = 0;
    state.lastMsg = "";

    state.tick = function(dr, dc) {
      let { grid, pr, pc, goal, enemies, hp, score, gold, totalTurns, levelTurns } = state;
      if (hp <= 0) return { done: true, won: false };
      if (pr === goal[0] && pc === goal[1]) {
        state.totalTurns = totalTurns + levelTurns;
        return { done: true, won: true };
      }

      const nr = pr + dr, nc = pc + dc;
      const cell = getCell(grid, nr, nc);

      if (cell === W) {
        if (mode === "tron") {
          state.hp = 0;
          state.totalTurns = totalTurns + levelTurns;
          state.lastMsg = "CRASH! Hit wall.";
          return { done: true, won: false };
        }
        state.lastMsg = "Blocked by wall.";
        return { done: false };
      }
      if (mode === "tron" && cell === T) {
        state.hp = 0;
        state.totalTurns = totalTurns + levelTurns;
        state.lastMsg = "CRASH! Hit trail.";
        return { done: true, won: false };
      }

      if (mode === "tron") setCell(grid, pr, pc, T);
      else setCell(grid, pr, pc, (pr === goal[0] && pc === goal[1]) ? G : F);

      let newEnemies = enemies;
      if (cell === E) {
        newEnemies = enemies.filter(([r, c]) => r !== nr || c !== nc);
        setCell(grid, nr, nc, F);
        score++;
        hp--;
        state.lastMsg = "You killed an enemy! (-1 HP)";
      } else if (cell === H) {
        setCell(grid, nr, nc, F);
        hp = Math.min(MAX_HP, hp + 1);
        state.lastMsg = "Health +1";
      } else if (cell === $) {
        setCell(grid, nr, nc, F);
        gold++;
        state.lastMsg = "Gold +1";
      } else {
        state.lastMsg = "";
      }

      setCell(grid, nr, nc, P);
      levelTurns++;
      const dmg = moveEnemies(grid, newEnemies, nr, nc, mode === "tron");
      if (dmg > 0) {
        hp -= dmg;
        state.lastMsg = "Enemy hit you! (-" + dmg + " HP)";
      } else if (!state.lastMsg) state.lastMsg = "Moved.";

      state.grid = grid;
      state.pr = nr;
      state.pc = nc;
      state.goal = goal;
      state.enemies = newEnemies;
      state.hp = hp;
      state.score = score;
      state.gold = gold;
      state.totalTurns = totalTurns + levelTurns;
      state.levelTurns = levelTurns;
      return { done: false };
    };
    return state;
  }

  function drawPlay(state) {
    if (state.grid) renderGrid(state.grid);
    document.getElementById("stats").textContent =
      `HP: ${state.hp}/${MAX_HP}   Kills: ${state.score}   Gold: ${state.gold}   Turn: ${state.totalTurns ?? 0}`;
    document.getElementById("msg").textContent = state.lastMsg ? ">> " + state.lastMsg : "";
    document.getElementById("level-title").textContent =
      mode === "tron" ? `TRON   Level ${(state.levelNum ?? 0) + 1}/${LEVELS.length}` : `CLASSIC   Level ${(state.levelNum ?? 0) + 1}/${LEVELS.length}`;
  }

  function showScreen(id) {
    document.querySelectorAll(".screen").forEach(el => el.classList.add("hidden"));
    const el = document.getElementById(id);
    if (el) el.classList.remove("hidden");
  }

  function startGame() {
    state = { hp: 4, score: 0, gold: 0, totalTurns: 0 };
    runLevel(0);
    document.getElementById("game-wrap").classList.remove("hidden");
    document.getElementById("level-title").classList.remove("hidden");
    drawPlay(state);
    showScreen("play");
  }

  function onKey(e) {
    if (!state || !state.tick) return;
    let dr = 0, dc = 0;
    const k = e.key.toLowerCase();
    if (k === "arrowup" || k === "w") dr = -1;
    else if (k === "arrowdown" || k === "s") dr = 1;
    else if (k === "arrowleft" || k === "a") dc = -1;
    else if (k === "arrowright" || k === "d") dc = 1;
    else return;
    e.preventDefault();

    const res = state.tick(dr, dc);

    if (res.done) {
      state.tick = null;
      if (res.won && (state.levelNum + 1) < LEVELS.length) {
        state.levelNum = state.levelNum + 1;
        runLevel(state.levelNum);
        drawPlay(state);
        return;
      }
      if (res.won) {
        const best = loadBest();
        if (isBetter(state.gold, state.totalTurns, best)) { saveBest(state.gold, state.totalTurns); }
        document.getElementById("win-stats").innerHTML =
          `All ${LEVELS.length} levels cleared.<br>Kills: ${state.score}   Gold: ${state.gold}   Turns: ${state.totalTurns}`;
        const b = loadBest();
        document.getElementById("win-best").textContent = b ? `Best: ${b.gold} gold, ${b.turns} turns` : "";
        showScreen("win");
      } else {
        const best = loadBest();
        if (isBetter(state.gold, state.turns, best)) saveBest(state.gold, state.turns);
        document.getElementById("over-stats").textContent =
          `Level ${(state.levelNum ?? 0) + 1}   Kills: ${state.score}   Gold: ${state.gold}   Turns: ${state.totalTurns}`;
        const b = loadBest();
        document.getElementById("over-best").textContent = b ? `Best: ${b.gold} gold, ${b.turns} turns` : "";
        showScreen("gameover");
      }
      document.getElementById("game-wrap").classList.add("hidden");
      return;
    }
    drawPlay(state);
  }

  function init() {
    const app = document.getElementById("app");
    app.innerHTML = `
      <div class="screen" id="menu">
        <h1>DUNGEON CRAWLER</h1>
        <p class="sub">by Mark Kaminsky</p>
        <p class="sub">Reach G · Kill E · + health · $ gold</p>
        <p style="font-size:0.85rem; color:#86efac; margin-bottom:0.5rem;">Reach the goal. Don’t die. Arrows or W A S D.</p>
        <p>Choose mode</p>
        <button class="btn" data-mode="classic">Classic</button>
        <button class="btn" data-mode="tron">Tron</button>
      </div>
      <div class="screen hidden" id="play">
        <h2 id="level-title"></h2>
        <div id="game-wrap" class="hidden">
          <div id="grid-wrap"><div id="grid"></div></div>
          <div id="stats"></div>
          <div id="msg"></div>
          <p id="controls">Arrows or W A S D</p>
        </div>
      </div>
      <div class="screen hidden" id="gameover">
        <h2 style="color:#f87171">GAME OVER</h2>
        <p id="over-stats"></p>
        <p id="over-best"></p>
        <button class="btn" onclick="location.reload()">Play again</button>
      </div>
      <div class="screen hidden" id="win">
        <h2 style="color:#86efac">YOU WON!</h2>
        <p id="win-stats"></p>
        <p id="win-best"></p>
        <button class="btn" onclick="location.reload()">Play again</button>
      </div>
    `;
    app.querySelectorAll("[data-mode]").forEach(btn => {
      btn.addEventListener("click", () => {
        mode = btn.dataset.mode;
        startGame();
      });
    });
    document.addEventListener("keydown", onKey);
  }
  init();
})();
  </script>
</body>
</html>
